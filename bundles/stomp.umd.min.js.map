{"version":3,"sources":["webpack://StompJs/webpack/universalModuleDefinition","webpack://StompJs/webpack/bootstrap","webpack://StompJs/./src/stomp.ts","webpack://StompJs/./src/byte.ts","webpack://StompJs/./src/frame.ts","webpack://StompJs/./src/client.ts","webpack://StompJs/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","client_1","Stomp","client","url","protocols","Client","WebSocketClass","WebSocket","over","ws","ws_fn","setInterval","interval","f","clearInterval","id","VERSIONS","V1_0","V1_1","V1_2","supportedVersions","Byte","LF","NULL","byte_1","Frame","command","headers","body","escapeHeaderValues","this","toString","lines","skipContentLength","_i","_a","keys","length","name_1","push","frEscape","sizeOfUTF8","join","encodeURI","match","unmarshallSingle","data","divider","search","RegExp","headerLines","substring","split","shift","trim","str","replace","reverse","line","idx","indexOf","frUnEscape","start","len","parseInt","chr","end","asc","charAt","unmarshall","datas","frames","partial","slice","map","frame","last_frame","marshall","frame_1","stomp_1","debug","message","arguments","console","log","apply","binaryType","reconnect_delay","counter","connected","heartbeat","outgoing","incoming","maxWebSocketFrameSize","subscriptions","partialData","now","Date","valueOf","_transmit","out","send","_setupHeartbeat","ttl","_this","version","v","serverOutgoing","serverIncoming","Math","max","pinger","undefined","ponger","delta","serverActivity","close","_parseConnect","closeEventCallback","connectCallback","errorCallback","args","connect","_active","_connect","onmessage","evt","ArrayBuffer","arr","Uint8Array","len1","j","results","String","fromCharCode","unmarshalledData","server","disconnect","subscription_1","subscription","onreceive","messageID_1","ack","nack","closeReceipt","onclose","_cleanUp","_disconnectCallback","onreceipt","closeEvent","msg","_schedule_reconnect","onopen","_reconnector","setTimeout","disconnectCallback","error","clearTimeout","destination","subscribe","callback","unsubscribe","hdrs","begin","transaction_id","txid","transaction","commit","abort","messageID","__export"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,aAAAH,GACA,iBAAAC,QACAA,QAAA,QAAAD,IAEAD,EAAA,QAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,mFCvDA,IAAAC,EAAAlC,EAAA,GAUAmC,EAAA,oBAAAA,KA2EA,OApDgBA,EAAAC,OAAd,SAAsBC,EAAKC,GAcR,MAAbA,IAAqBA,GAAa,YAAa,YAAa,cAMhE,OAAO,IAAIJ,EAAAK,OALE,WAEX,OAAO,IADOJ,EAAMK,gBAAkBC,WACrBJ,EAAKC,MAsBZH,EAAAO,KAAd,SAAoBC,GAClB,IAAMC,EAAuB,mBAAT,EAAsBD,EAAK,WAAM,OAAAA,GAErD,OAAO,IAAIT,EAAAK,OAAOK,IAGNT,EAAAU,YAAd,SAA0BC,EAAUC,GAClCF,YAAYE,EAAGD,IAGHX,EAAAa,cAAd,SAA4BC,GAC1BD,cAAcC,IAvEFd,EAAAe,UACZC,KAAM,MACNC,KAAM,MACNC,KAAM,MAGNC,kBAAmB,WACjB,MAAO,gBAIGnB,EAAAK,eAAiB,KA8DjCL,EA3EA,GAAazC,EAAAyC,uFCrCAzC,EAAA6D,MAEXC,GAAI,KAEJC,KAAM,qFCCR,IAAAC,EAAA1D,EAAA,GAEA2D,EAAA,WAcE,SAAAA,EAAYC,EAAiBC,EAA4BC,EAAgBC,QAA5C,IAAAF,eAA4B,IAAAC,MAAA,SAAgB,IAAAC,OAAA,GACvEC,KAAKJ,QAAUA,EACfI,KAAKH,QAAUA,EACfG,KAAKF,KAAOA,EACZE,KAAKD,mBAAqBA,EAgJ9B,OAzISJ,EAAA7B,UAAAmC,SAAP,WACE,IAAMC,GAASF,KAAKJ,SACdO,GAAwD,IAAnCH,KAAKH,QAAQ,kBACpCM,UACKH,KAAKH,QAAQ,kBAGtB,IAAiB,IAAAO,EAAA,EAAAC,EAAAzD,OAAO0D,KAAKN,KAAKH,aAAjBO,EAAAC,EAAAE,OAAAH,IAAiC,CAA7C,IAAII,EAAIH,EAAAD,GACLjD,EAAQ6C,KAAKH,QAAQW,GACvBR,KAAKD,oBAAwC,YAAjBC,KAAKJ,SAA4C,cAAjBI,KAAKJ,QACnEM,EAAMO,KAAQD,EAAI,IAAIb,EAAMe,SAAS,GAAGvD,IAExC+C,EAAMO,KAAQD,EAAI,IAAIrD,GAO1B,OAJI6C,KAAKF,OAASK,GAChBD,EAAMO,KAAK,kBAAkBd,EAAMgB,WAAWX,KAAKF,OAErDI,EAAMO,KAAKf,EAAAH,KAAKC,GAAKQ,KAAKF,MACnBI,EAAMU,KAAKlB,EAAAH,KAAKC,KAOVG,EAAAgB,WAAf,SAA0B1C,GACxB,OAAIA,EACK4C,UAAU5C,GAAG6C,MAAM,UAAUP,OAE7B,GAOGZ,EAAAoB,iBAAd,SAA+BC,EAAWjB,GAWxC,IARA,IAAMkB,EAAUD,EAAKE,OAAO,IAAIC,OAAO,GAAGzB,EAAAH,KAAKC,GAAKE,EAAAH,KAAKC,KACnD4B,EAAcJ,EAAKK,UAAU,EAAGJ,GAASK,MAAM5B,EAAAH,KAAKC,IACpDI,EAAUwB,EAAYG,QACtB1B,KAEA2B,EAAO,SAAAC,GAAO,OAAAA,EAAIC,QAAQ,aAAc,KAG7BtB,EAAA,EAAAC,EAAAe,EAAYO,UAAZvB,EAAAC,EAAAE,OAAAH,IAAuB,CAAnC,IAAIwB,EAAIvB,EAAAD,GACLyB,EAAMD,EAAKE,QAAQ,KAEvBjC,EAAQ2B,EAAKI,EAAKP,UAAU,EAAGQ,KAD7B9B,GAAmC,YAAZH,GAAuC,cAAZA,EACZD,EAAMoC,WAAWP,EAAKI,EAAKP,UAAUQ,EAAM,KAE3CL,EAAKI,EAAKP,UAAUQ,EAAM,IAKtE,IAAI/B,EAAO,GAELkC,EAAQf,EAAU,EACxB,GAAIpB,EAAQ,kBAAmB,CAC7B,IAAMoC,EAAMC,SAASrC,EAAQ,mBAC7BC,GAAQ,GAAGkB,GAAQK,UAAUW,EAAOA,EAAQC,QAG5C,IADA,IAAIE,EAAM,KACDjG,EAAI8F,EAAOI,EAAMpB,EAAKT,OAAQ8B,EAAML,GAASI,GAAKC,EAAMnG,EAAIkG,EAAMlG,EAAIkG,KAC7ED,EAAMnB,EAAKsB,OAAOpG,MACNwD,EAAAH,KAAKE,KAFiE4C,EAAMnG,IAAMA,IAK9F4D,GAAQqC,EAGZ,OAAO,IAAIxC,EAAMC,EAASC,EAASC,EAAMC,IAa7BJ,EAAA4C,WAAd,SAAyBC,EAAYzC,GAKT,MAAtBA,IACFA,GAAqB,GAEvB,IAAM0C,EAASD,EAAMlB,MAAM,IAAIH,OAAO,GAAGzB,EAAAH,KAAKE,KAAOC,EAAAH,KAAKC,GAAE,MAEtDxC,GACJyF,UACAC,QAAS,IAEX1F,EAAEyF,OAAUA,EAAOE,MAAM,GAAI,GAAGC,IAAI,SAACC,GAAU,OAAAlD,EAAMoB,iBAAiB8B,EAAO9C,KAK7E,IAAM+C,EAAaL,EAAOE,OAAO,GAAG,GAOpC,OALKG,IAAepD,EAAAH,KAAKC,KAAyE,IAAhEsD,EAAW5B,OAAO,IAAIC,OAAO,GAAGzB,EAAAH,KAAKE,KAAOC,EAAAH,KAAKC,GAAE,OACnFxC,EAAEyF,OAAOhC,KAAKd,EAAMoB,iBAAiB+B,EAAY/C,IAEjD/C,EAAE0F,QAAUI,EAEP9F,GAMK2C,EAAAoD,SAAd,SAAuBnD,EAAiBC,EAAuBC,EAAWC,GAExE,OADc,IAAIJ,EAAMC,EAASC,EAASC,EAAMC,GACnCE,WAAaP,EAAAH,KAAKE,MAMlBE,EAAAe,SAAf,SAAwBe,GACtB,OAAOA,EAAIC,QAAQ,MAAO,QAAQA,QAAQ,MAAO,OAAOA,QAAQ,MAAO,OAAOA,QAAQ,KAAM,QAM/E/B,EAAAoC,WAAf,SAA0BN,GACxB,OAAOA,EAAIC,QAAQ,OAAQ,MAAMA,QAAQ,OAAQ,MAAMA,QAAQ,OAAQ,KAAKA,QAAQ,QAAS,OAEjG/B,EAlKA,GAAajE,EAAAiE,uFCDb,IAAAqD,EAAAhH,EAAA,GACAiH,EAAAjH,EAAA,GACA0D,EAAA1D,EAAA,GAGAuC,EAAA,WA0CI,SAAAA,EAAYK,GAqDLoB,KAAAkD,MAAQ,eAAC,IAAAC,KAAA/C,EAAA,EAAAA,EAAAgD,UAAA7C,OAAAH,IAAA+C,EAAA/C,GAAAgD,UAAAhD,GACdiD,QAAQC,IAAGC,MAAXF,QAAeF,IArDfnD,KAAKpB,MAAQ,WACX,IAAMD,EAAKC,IAEX,OADAD,EAAG6E,WAAa,cACT7E,GAITqB,KAAKyD,gBAAkB,EAGvBzD,KAAK0D,QAAU,EAGf1D,KAAK2D,WAAY,EAIjB3D,KAAK4D,WAEHC,SAAU,IAGVC,SAAU,KAKZ9D,KAAK+D,sBAAwB,MAE7B/D,KAAKgE,iBACLhE,KAAKiE,YAAc,GA2oBvB,OAzrBgB1F,EAAA2F,IAAd,WACE,OAAIC,KAAKD,IACAC,KAAKD,OAEL,IAAIC,MAAOC,SAuEd7F,EAAAT,UAAAuG,UAAR,SAAkBzE,EAASC,EAASC,QAAA,IAAAA,MAAA,IAClC,IAAIwE,EAAMtB,EAAArD,MAAMoD,SAASnD,EAASC,EAASC,EAAME,KAAKD,oBAMtD,IAL0B,mBAAfC,KAAKkD,OACdlD,KAAKkD,MAAM,OAAOoB,KAIP,CACX,KAAIA,EAAI/D,OAASP,KAAK+D,uBAQpB,YADA/D,KAAKrB,GAAG4F,KAAKD,GANbtE,KAAKrB,GAAG4F,KAAKD,EAAIjD,UAAU,EAAGrB,KAAK+D,wBACnCO,EAAMA,EAAIjD,UAAUrB,KAAK+D,uBACC,mBAAf/D,KAAKkD,OACdlD,KAAKkD,MAAM,eAAeoB,EAAI/D,UAYtChC,EAAAT,UAAA0G,gBAAA,SAAgB3E,GAAhB,IACM4E,EADNC,EAAA1E,KAEE,GAAKH,EAAQ8E,UAAY1B,EAAA9E,MAAMe,SAASE,MAAQS,EAAQ8E,UAAY1B,EAAA9E,MAAMe,SAASG,KAAnF,CAOM,IAAAgB,EAAAR,EAAA,cAAAyB,MAAA,KAAAsB,IAAA,SAAAgC,GAAA,OAAA1C,SAAA0C,KAACC,EAAAxE,EAAA,GAAgByE,EAAAzE,EAAA,GAevB,OAbiC,IAA5BL,KAAK4D,UAAUC,UAAuC,IAAnBiB,IACtCL,EAAMM,KAAKC,IAAIhF,KAAK4D,UAAUC,SAAUiB,GACd,mBAAf9E,KAAKkD,OACdlD,KAAKkD,MAAM,mBAAmBuB,EAAG,MAInCzE,KAAKiF,OAAShC,EAAA9E,MAAMU,YAAY4F,EAAK,WAEnC,OADAC,EAAK/F,GAAG4F,KAAK7E,EAAAH,KAAKC,IACY,mBAAfkF,EAAKxB,MAAuBwB,EAAKxB,MAAM,iBAAcgC,KAIvC,IAA5BlF,KAAK4D,UAAUE,UAAuC,IAAnBe,GACtCJ,EAAMM,KAAKC,IAAIhF,KAAK4D,UAAUE,SAAUe,GACd,mBAAf7E,KAAKkD,OACdlD,KAAKkD,MAAM,oBAAoBuB,EAAG,MAE7BzE,KAAKmF,OAASlC,EAAA9E,MAAMU,YAAY4F,EAAK,WAC1C,IAAMW,EAAQ7G,EAAO2F,MAAQQ,EAAKW,eAElC,GAAID,EAAe,EAANX,EAIX,MAH0B,mBAAfC,EAAKxB,OACdwB,EAAKxB,MAAM,gDAAgDkC,EAAK,MAE3DV,EAAK/F,GAAG2G,gBAZrB,IAsBF/G,EAAAT,UAAAyH,cAAA,eAAc,IACRC,EAAoBC,EAAiBC,EAD7BC,KAAAvF,EAAA,EAAAA,EAAAgD,UAAA7C,OAAAH,IAAAuF,EAAAvF,GAAAgD,UAAAhD,GAEZ,IAAIP,KACJ,GAAI8F,EAAKpF,OAAS,EAChB,KAAK,wCAEP,GAAwB,mBAAboF,EAAK,GACb9F,EAAA8F,EAAA,GAASF,EAAAE,EAAA,GAAiBD,EAAAC,EAAA,GAAeH,EAAAG,EAAA,QAE1C,OAAQA,EAAKpF,QACX,KAAK,EACFV,EAAA,MAAA8F,EAAA,GAAkB9F,EAAA,SAAA8F,EAAA,GAAqBF,EAAAE,EAAA,GAAiBD,EAAAC,EAAA,GAAeH,EAAAG,EAAA,GAAoB9F,EAAA,KAAA8F,EAAA,GAC5F,MACF,QACG9F,EAAA,MAAA8F,EAAA,GAAkB9F,EAAA,SAAA8F,EAAA,GAAqBF,EAAAE,EAAA,GAAiBD,EAAAC,EAAA,GAAeH,EAAAG,EAAA,GAI9E,OAAQ9F,EAAS4F,EAAiBC,EAAeF,IAyCnDjH,EAAAT,UAAA8H,QAAA,eAAQ,IAAAD,KAAAvF,EAAA,EAAAA,EAAAgD,UAAA7C,OAAAH,IAAAuF,EAAAvF,GAAAgD,UAAAhD,GACNJ,KAAKD,oBAAqB,EAC1B,IAAMuE,EAAMtE,KAAKuF,cAAahC,MAAlBvD,KAAsB2F,GAMlC,OALC3F,KAAAH,QAAAyE,EAAA,GAActE,KAAAyF,gBAAAnB,EAAA,GAAsBtE,KAAA0F,cAAApB,EAAA,GAAoBtE,KAAAwF,mBAAAlB,EAAA,GAGzDtE,KAAK6F,SAAU,EAER7F,KAAK8F,YAMdvH,EAAAT,UAAAgI,SAAA,eAAApB,EAAA1E,KACSH,EAAAG,KAAAH,QACA6F,EAAA1F,KAAA0F,cACAF,EAAAxF,KAAAwF,mBA6KP,OA3KAxF,KAAKkD,MAAMrD,GAEe,mBAAfG,KAAKkD,OACdlD,KAAKkD,MAAM,yBAIblD,KAAKrB,GAAKqB,KAAKpB,QAEfoB,KAAKrB,GAAGoH,UAAY,SAAAC,GAClBtB,EAAKxB,MAAM,iBACX,IAAMlC,EAAO,WACX,GAA6B,oBAAlB,aAAkCgF,EAAIhF,gBAAgBiF,YAAa,CAG5E,IAAMC,EAAM,IAAIC,WAAWH,EAAIhF,MACL,mBAAf0D,EAAKxB,OACdwB,EAAKxB,MAAM,wBAAwBgD,EAAI3F,QAGzC,IAAO6F,EAAHC,OAAC,EAAQC,OAAO,EAEpB,IADAA,KACKD,EAAI,EAAGD,EAAOF,EAAI3F,OAAQ8F,EAAID,EAAMC,IAAK,CAC5C,IAAM9J,EAAI2J,EAAIG,GACdC,EAAQ7F,KAAK8F,OAAOC,aAAajK,IAGnC,OAAO+J,EAAQ1F,KAAK,IAGpB,OAAOoF,EAAIhF,KAnBF,GAwBb,GAFA0D,EAAKxB,MAAMlC,GACX0D,EAAKW,eAAiB9G,EAAO2F,MACzBlD,IAAStB,EAAAH,KAAKC,GAAlB,CAM0B,mBAAfkF,EAAKxB,OACdwB,EAAKxB,MAAM,OAAOlC,GAKpB,IAAMyF,EAAmBzD,EAAArD,MAAM4C,WAAWmC,EAAKT,YAAcjD,EAAM0D,EAAK3E,oBACxE2E,EAAKT,YAAcwC,EAAiB/D,QACpC,mBAASG,GACP,OAAQA,EAAMjD,SAEZ,IAAK,YAYH,GAX0B,mBAAf8E,EAAKxB,OACdwB,EAAKxB,MAAM,uBAAuBL,EAAMhD,QAAQ6G,QAElDhC,EAAKf,WAAY,EACjBe,EAAKC,QAAU9B,EAAMhD,QAAQ8E,QAEzBD,EAAKC,UAAY1B,EAAA9E,MAAMe,SAASG,OAClCqF,EAAK3E,oBAAqB,IAIvB2E,EAAKmB,eAGRnB,EAAKiC,WAAW,6BAIlBjC,EAAKF,gBAAgB3B,EAAMhD,SACS,mBAAzB6E,EAAKe,iBACdf,EAAKe,gBAAgB5C,GAEvB,MAEF,IAAK,UAQI,IAAA+D,EAAA/D,EAAAhD,QAAAgH,aACDC,EAAYpC,EAAKV,cAAc4C,IAAiBlC,EAAKoC,UAC3D,GAAIA,EAAW,CACb,IAAIC,EACE7I,EAASwG,EAEbqC,EADErC,EAAKC,UAAY1B,EAAA9E,MAAMe,SAASG,KACtBwD,EAAMhD,QAAa,IAEnBgD,EAAMhD,QAAQ,cAI5BgD,EAAMmE,IAAM,SAAAnH,GAIV,OAHe,MAAXA,IACFA,MAEK3B,EAAO8I,IAAID,EAAWH,EAAc/G,IAE7CgD,EAAMoE,KAAO,SAAApH,GAIX,OAHe,MAAXA,IACFA,MAEK3B,EAAO+I,KAAKF,EAAWH,EAAc/G,IAE9CiH,EAAUjE,OAEgB,mBAAf6B,EAAKxB,OACdwB,EAAKxB,MAAM,+BAA+BL,GAG9C,MAWF,IAAK,UAECA,EAAMhD,QAAQ,gBAAkB6E,EAAKwC,cAGvCxC,EAAK/F,GAAGwI,QAAU,KAClBzC,EAAK/F,GAAG2G,QACRZ,EAAK0C,WACmC,mBAA7B1C,EAAK2C,qBACd3C,EAAK2C,uBAGuB,mBAAnB3C,EAAK4C,WACd5C,EAAK4C,UAAUzE,GAGnB,MAEF,IAAK,QAC0B,mBAAlB6C,GACTA,EAAc7C,GAEhB,MACF,QAC4B,mBAAf6B,EAAKxB,OACdwB,EAAKxB,MAAM,oBAAoBL,KAtGrBzC,EAAA,EAAAC,EAAAoG,EAAiBhE,OAAjBrC,EAAAC,EAAAE,OAAAH,IAAuB,CAApC,QAASC,EAAAD,8CAbc,mBAAfsE,EAAKxB,OACdwB,EAAKxB,MAAM,aAuHjBlD,KAAKrB,GAAGwI,QAAU,SAAAI,GAChB,IAAMC,EAAM,8BAA8B9C,EAAK/F,GAAGN,IAWlD,MAV0B,mBAAfqG,EAAKxB,OACdwB,EAAKxB,MAAMsE,GAEqB,mBAAvBhC,GACTA,EAAmB+B,GAErB7C,EAAK0C,WACwB,mBAAlB1B,GACTA,EAAc8B,GAET9C,EAAK+C,uBAGPzH,KAAKrB,GAAG+I,OAAS,WACI,mBAAfhD,EAAKxB,OACdwB,EAAKxB,MAAM,wBAEbrD,EAAQ,kBAAoBoD,EAAA9E,MAAMe,SAASI,oBAC3CO,EAAQ,eAAiB6E,EAAKd,UAAUC,SAAUa,EAAKd,UAAUE,UAAUlD,KAAK,KAChF8D,EAAKxB,MAAMrD,GACX6E,EAAKL,UAAU,UAAWxE,KAM9BtB,EAAAT,UAAA2J,oBAAA,eAAA/C,EAAA1E,KACE,GAAIA,KAAKyD,gBAAkB,EAKzB,MAJ0B,mBAAfzD,KAAKkD,OACdlD,KAAKkD,MAAM,qCAAqClD,KAAKyD,gBAAe,MAG/DzD,KAAK2H,aAAeC,WAAW,WAClC,OAAIlD,EAAKf,UACuB,mBAAfe,EAAKxB,MAAuBwB,EAAKxB,MAAM,iCAA8BgC,GAE1D,mBAAfR,EAAKxB,OACdwB,EAAKxB,MAAM,kCAENwB,EAAKoB,aAGd9F,KAAKyD,kBAablF,EAAAT,UAAA6I,WAAA,SAAWkB,EAAoBhI,GAM7B,QAN6B,IAAAA,UAC7BG,KAAKqH,oBAAsBQ,EAG3B7H,KAAK6F,SAAU,EAEX7F,KAAK2D,UAAW,CACb9D,EAAiB,UACpBA,EAAiB,QAAI,SAASG,KAAK0D,WAErC1D,KAAKkH,aAAerH,EAAiB,QACrC,IACE,OAAOG,KAAKqE,UAAU,aAAcxE,GACpC,MAAOiI,GACP,MAA8B,mBAAf9H,KAAKkD,MAAuBlD,KAAKkD,MAAM,mCAAoC4E,QAAS5C,KASzG3G,EAAAT,UAAAsJ,SAAA,WAYE,GAVIpH,KAAK2H,cACPI,aAAa/H,KAAK2H,cAGpB3H,KAAK2D,WAAY,EACjB3D,KAAKgE,iBACLhE,KAAK0C,QAAU,GACX1C,KAAKiF,QACPhC,EAAA9E,MAAMa,cAAcgB,KAAKiF,QAEvBjF,KAAKmF,OACP,OAAOlC,EAAA9E,MAAMa,cAAcgB,KAAKmF,SAsBpC5G,EAAAT,UAAAyG,KAAA,SAAKyD,EAAanI,EAASC,GAQzB,OAPe,MAAXD,IACFA,MAEU,MAARC,IACFA,EAAO,IAETD,EAAQmI,YAAcA,EACfhI,KAAKqE,UAAU,OAAQxE,EAASC,IA8BzCvB,EAAAT,UAAAmK,UAAA,SAAUD,EAAaE,EAAUrI,GAGhB,MAAXA,IACFA,MAEGA,EAAQZ,KACXY,EAAQZ,GAAK,OAAOe,KAAK0D,WAE3B7D,EAAQmI,YAAcA,EACtBhI,KAAKgE,cAAcnE,EAAQZ,IAAMiJ,EACjClI,KAAKqE,UAAU,YAAaxE,GAC5B,IAAMzB,EAAS4B,KACf,OACEf,GAAIY,EAAQZ,GAEZkJ,YAAW,SAACC,GACV,OAAOhK,EAAO+J,YAAYtI,EAAQZ,GAAImJ,MAiB5C7J,EAAAT,UAAAqK,YAAA,SAAYlJ,EAAIY,GAMd,OALe,MAAXA,IACFA,aAEKG,KAAKgE,cAAc/E,GAC1BY,EAAQZ,GAAKA,EACNe,KAAKqE,UAAU,cAAexE,IAWvCtB,EAAAT,UAAAuK,MAAA,SAAMC,GACJ,IAAMC,EAAOD,GAAmB,MAAMtI,KAAK0D,UAC3C1D,KAAKqE,UAAU,SACbmE,YAAaD,IAEf,IAAMnK,EAAS4B,KACf,OACEf,GAAIsJ,EACJE,OAAM,WACJ,OAAOrK,EAAOqK,OAAOF,IAEvBG,MAAK,WACH,OAAOtK,EAAOsK,MAAMH,MAiB1BhK,EAAAT,UAAA2K,OAAA,SAAOH,GACL,OAAOtI,KAAKqE,UAAU,UACpBmE,YAAaF,KAgBjB/J,EAAAT,UAAA4K,MAAA,SAAMJ,GACJ,OAAOtI,KAAKqE,UAAU,SACpBmE,YAAaF,KAsBjB/J,EAAAT,UAAAkJ,IAAA,SAAI2B,EAAW9B,EAAchH,GAU3B,OATe,MAAXA,IACFA,MAEEG,KAAK2E,UAAY1B,EAAA9E,MAAMe,SAASG,KAClCQ,EAAY,GAAI8I,EAEhB9I,EAAQ,cAAgB8I,EAE1B9I,EAAQgH,aAAeA,EAChB7G,KAAKqE,UAAU,MAAOxE,IAqB/BtB,EAAAT,UAAAmJ,KAAA,SAAK0B,EAAW9B,EAAchH,GAU5B,OATe,MAAXA,IACFA,MAEEG,KAAK2E,UAAY1B,EAAA9E,MAAMe,SAASG,KAClCQ,EAAY,GAAI8I,EAEhB9I,EAAQ,cAAgB8I,EAE1B9I,EAAQgH,aAAeA,EAChB7G,KAAKqE,UAAU,OAAQxE,IAElCtB,EAptBF,GAAa7C,EAAA6C,sJCRbqK,EAAA5M,EAAA,IACA4M,EAAA5M,EAAA,IACA4M,EAAA5M,EAAA","file":"stomp.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StompJs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StompJs\"] = factory();\n\telse\n\t\troot[\"StompJs\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","// **STOMP Over Web Socket** is a JavaScript STOMP Client using\n// [HTML5 Web Sockets API](http://www.w3.org/TR/websockets).\n//\n// * Copyright (C) 2010-2012 [Jeff Mesnil](http://jmesnil.net/)\n// * Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)\n// * Copyright (C) 2017 [Deepak Kumar](https://www.kreatio.com)\n//\n// This library supports:\n//\n// * [STOMP 1.0](http://stomp.github.com/stomp-specification-1.0.html)\n// * [STOMP 1.1](http://stomp.github.com/stomp-specification-1.1.html)\n// * [STOMP 1.2](http://stomp.github.com/stomp-specification-1.2.html)\n//\n// The library is accessed through the `Stomp` object that is set on the `window`\n// when running in a Web browser.\n\n/*\n   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0\n\n   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)\n   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)\n   Copyright (C) 2017 [Deepak Kumar](https://www.kreatio.com)\n*/\n\n// @mixin\n//\n// @private\nimport {Client} from \"./client\";\n\n\n// STOMP Client Class\n//\n// All STOMP protocol is exposed as methods of this class (`connect()`,\n\n// Stomp exposes methods to instantiate Client.\n//\n// @mixin\nexport class Stomp {\n  // @private\n  public static VERSIONS = {\n    V1_0: '1.0',\n    V1_1: '1.1',\n    V1_2: '1.2',\n\n    // Versions of STOMP specifications supported\n    supportedVersions: function() {\n      return '1.2,1.1,1.0';\n    }\n  };\n\n  public static WebSocketClass = null;\n\n  // This method creates a WebSocket client that is connected to\n  // the STOMP server located at the url.\n  //\n  // @example\n  //        var url = \"ws://localhost:61614/stomp\";\n  //        var client = Stomp.client(url);\n  //\n  // @param url [String]\n  public static client (url, protocols) {\n    // This is a hack to allow another implementation than the standard\n    // HTML5 WebSocket class.\n    //\n    // It is possible to use another class by calling\n    //\n    //     Stomp.WebSocketClass = MozWebSocket\n    //\n    // *prior* to call `Stomp.client()`.\n    //\n    // This hack is deprecated and  `Stomp.over()` method should be used\n    // instead.\n\n    // See remarks on the function Stomp.over\n    if (protocols == null) { protocols = ['v10.stomp', 'v11.stomp', 'v12.stomp']; }\n    const ws_fn= function() {\n      const klass = Stomp.WebSocketClass || WebSocket;\n      return new klass(url, protocols);\n    };\n\n    return new Client(ws_fn);\n  }\n\n  // This method is an alternative to `Stomp.client()` to let the user\n  // specify the WebSocket to use (either a standard HTML5 WebSocket or\n  // a similar object).\n  //\n  // In order to support reconnection, the function Client._connect should be callable more than once. While reconnecting\n  // a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n  // alternatively allows passing a function that should return a new instance of the underlying socket.\n  //\n  // @example\n  //         var client = Stomp.over(function(){\n  //           return new WebSocket('ws://localhost:15674/ws')\n  //         });\n  //\n  // @param ws [WebSocket|function()] a WebSocket like Object or a function returning a WebObject or similar Object\n  //\n  // @note If you need auto reconnect feature you must pass a function that returns a WebSocket or similar Object\n  public static over (ws) {\n    const ws_fn = typeof(ws) === \"function\" ? ws : () => ws;\n\n    return new Client(ws_fn);\n  }\n\n  public static setInterval(interval, f) {\n    setInterval(f, interval);\n  }\n\n  public static clearInterval(id) {\n    clearInterval(id)\n  };\n}\n","export const Byte = {\n  // LINEFEED byte (octet 10)\n  LF: '\\x0A',\n  // NULL byte (octet 0)\n  NULL: '\\x00'\n};\n","// @see http://stomp.github.com/stomp-specification-1.2.html#STOMP_Frames STOMP Frame\n//\n// Frame class represents a STOMP frame\n//\nimport {StompHeaders} from \"./headers\";\nimport {Byte} from \"./byte\";\n\nexport class Frame {\n  public command: string;\n  public headers: StompHeaders;\n  public body: any;\n  public escapeHeaderValues: boolean;\n\n// Frame constructor. `command`, `headers` and `body` are available as properties.\n//\n// Many of the Client methods pass instance of received Frame to the callback.\n//\n// @param command [String]\n// @param headers [Object]\n// @param body [String]\n// @param escapeHeaderValues [Boolean]\n  constructor(command: string, headers: StompHeaders = {}, body: any = '', escapeHeaderValues: boolean = false) {\n    this.command = command;\n    this.headers = headers;\n    this.body = body;\n    this.escapeHeaderValues = escapeHeaderValues;\n  }\n\n// Provides a textual representation of the frame\n// suitable to be sent to the server\n//\n// @private\n  public toString(): string {\n    const lines = [this.command];\n    const skipContentLength = (this.headers['content-length'] === false) ? true : false;\n    if (skipContentLength) {\n      delete this.headers['content-length'];\n    }\n\n    for (let name of Object.keys(this.headers || {})) {\n      const value = this.headers[name];\n      if (this.escapeHeaderValues && (this.command !== 'CONNECT') && (this.command !== 'CONNECTED')) {\n        lines.push(`${name}:${Frame.frEscape(`${value}`)}`);\n      } else {\n        lines.push(`${name}:${value}`);\n      }\n    }\n    if (this.body && !skipContentLength) {\n      lines.push(`content-length:${Frame.sizeOfUTF8(this.body)}`);\n    }\n    lines.push(Byte.LF + this.body);\n    return lines.join(Byte.LF);\n  }\n\n// Compute the size of a UTF-8 string by counting its number of bytes\n// (and not the number of characters composing the string)\n//\n// @private\n  private static sizeOfUTF8(s: string): number {\n    if (s) {\n      return encodeURI(s).match(/%..|./g).length;\n    } else {\n      return 0;\n    }\n  }\n\n  // Unmarshall a single STOMP frame from a `data` string\n  //\n  // @private\n  public static unmarshallSingle(data: any, escapeHeaderValues: boolean): Frame {\n    // search for 2 consecutives LF byte to split the command\n    // and headers from the body\n    const divider = data.search(new RegExp(`${Byte.LF}${Byte.LF}`));\n    const headerLines = data.substring(0, divider).split(Byte.LF);\n    const command = headerLines.shift();\n    const headers = {};\n    // utility function to trim any whitespace before and after a string\n    const trim = str => str.replace(/^\\s+|\\s+$/g, '');\n    // Parse headers in reverse order so that for repeated headers, the 1st\n    // value is used\n    for (let line of headerLines.reverse()) {\n      const idx = line.indexOf(':');\n      if (escapeHeaderValues && (command !== 'CONNECT') && (command !== 'CONNECTED')) {\n        headers[trim(line.substring(0, idx))] = Frame.frUnEscape(trim(line.substring(idx + 1)));\n      } else {\n        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n      }\n    }\n    // Parse body\n    // check for content-length or  topping at the first NULL byte found.\n    let body = '';\n    // skip the 2 LF bytes that divides the headers from the body\n    const start = divider + 2;\n    if (headers['content-length']) {\n      const len = parseInt(headers['content-length']);\n      body = (`${data}`).substring(start, start + len);\n    } else {\n      let chr = null;\n      for (let i = start, end = data.length, asc = start <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n        chr = data.charAt(i);\n        if (chr === Byte.NULL) {\n          break;\n        }\n        body += chr;\n      }\n    }\n    return new Frame(command, headers, body, escapeHeaderValues);\n  }\n\n// Split the data before unmarshalling every single STOMP frame.\n// Web socket servers can send multiple frames in a single websocket message.\n// If the message size exceeds the websocket message size, then a single\n// frame can be fragmented across multiple messages.\n//\n// `datas` is a string.\n//\n// returns an *array* of Frame objects\n//\n// @private\n  public static unmarshall(datas: any, escapeHeaderValues: boolean) {\n    // Ugly list comprehension to split and unmarshall *multiple STOMP frames*\n    // contained in a *single WebSocket frame*.\n    // The data is split when a NULL byte (followed by zero or many LF bytes) is\n    // found\n    if (escapeHeaderValues == null) {\n      escapeHeaderValues = false;\n    }\n    const frames = datas.split(new RegExp(`${Byte.NULL}${Byte.LF}*`));\n\n    const r = {\n      frames: [],\n      partial: ''\n    };\n    r.frames = (frames.slice(0, -1).map((frame) => Frame.unmarshallSingle(frame, escapeHeaderValues)));\n\n    // If this contains a final full message or just a acknowledgement of a PING\n    // without any other content, process this frame, otherwise return the\n    // contents of the buffer to the caller.\n    const last_frame = frames.slice(-1)[0];\n\n    if ((last_frame === Byte.LF) || ((last_frame.search(new RegExp(`${Byte.NULL}${Byte.LF}*$`))) !== -1)) {\n      r.frames.push(Frame.unmarshallSingle(last_frame, escapeHeaderValues));\n    } else {\n      r.partial = last_frame;\n    }\n    return r;\n  }\n\n// Marshall a Stomp frame\n//\n// @private\n  public static marshall(command: string, headers: StompHeaders, body: any, escapeHeaderValues: boolean) {\n    const frame = new Frame(command, headers, body, escapeHeaderValues);\n    return frame.toString() + Byte.NULL;\n  }\n\n// Escape header values\n//\n// @private\n  private static frEscape(str: string): string {\n    return str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\r/g, \"\\\\r\").replace(/\\n/g, \"\\\\n\").replace(/:/g, \"\\\\c\");\n  }\n\n// Escape header values\n//\n// @private\n  private static frUnEscape(str: string): string {\n    return str.replace(/\\\\r/g, \"\\r\").replace(/\\\\n/g, \"\\n\").replace(/\\\\c/g, \":\").replace(/\\\\\\\\/g, \"\\\\\");\n  }\n}\n","// STOMP Client Class\n//\n// All STOMP protocol is exposed as methods of this class (`connect()`,\n// `send()`, etc.)\n// `send()`, etc.)\n\nimport {Frame} from \"./frame\";\nimport {Stomp} from \"./stomp\";\nimport {Byte} from \"./byte\";\nimport {StompHeaders} from \"./headers\";\n\nexport class Client {\n  public ws_fn: () => any;\n  public reconnect_delay: number;\n  private counter: number;\n  private connected: boolean;\n  public heartbeat: { outgoing: number; incoming: number };\n  public maxWebSocketFrameSize: number;\n  private subscriptions: any;\n  private partialData: any;\n  private escapeHeaderValues: boolean;\n  public ws: WebSocket;\n  private pinger: any;\n  private ponger: any;\n  private serverActivity: any;\n  private headers: StompHeaders;\n  private connectCallback: any;\n  private errorCallback: any;\n  private closeEventCallback: any;\n  private _active: boolean;\n  private version: string;\n  private onreceive: any;\n  private closeReceipt: string;\n  private _disconnectCallback: any;\n  private onreceipt: any;\n  private _reconnector: any;\n  private partial: string;\n\n    public static now (): any {\n      if (Date.now) {\n        return Date.now();\n      } else {\n        return new Date().valueOf;\n      }\n    }\n\n    // Please do not create instance of this class directly, use one of the methods {Stomp~client}, {Stomp~over}\n    // or {overTCP}\n    // in Stomp.\n    //\n    // @private\n    //\n    // @see Stomp\n    constructor(ws_fn: () => any) {\n      this.ws_fn = function () {\n        const ws = ws_fn();\n        ws.binaryType = \"arraybuffer\";\n        return ws;\n      };\n\n      // @property reconnect_delay [Number] automatically reconnect with delay in milliseconds, set to 0 to disable\n      this.reconnect_delay = 0;\n\n      // used to index subscribers\n      this.counter = 0;\n\n      // @property [Boolean] current connection state\n      this.connected = false;\n\n      // @property [{outgoing: Number, incoming: Number}] outgoing and incoming\n      // heartbeat in milliseconds, set to 0 to disable\n      this.heartbeat = {\n        // send heartbeat every 10s by default (value is in ms)\n        outgoing: 10000,\n        // expect to receive server heartbeat at least every 10s by default\n        // (value in ms)\n        incoming: 10000\n      };\n      // maximum *WebSocket* frame size sent by the client. If the STOMP frame\n      // is bigger than this value, the STOMP frame will be sent using multiple\n      // WebSocket frames (default is 16KiB)\n      this.maxWebSocketFrameSize = 16 * 1024;\n      // subscription callbacks indexed by subscriber's ID\n      this.subscriptions = {};\n      this.partialData = '';\n    }\n\n    // By default, debug messages are logged in the window's console if it is defined.\n    // This method is called for every actual transmission of the STOMP frames over the\n    // WebSocket.\n    //\n    // It is possible to set a `debug(message)` method\n    // on a client instance to handle differently the debug messages:\n    //\n    // @example\n    //     client.debug = function(str) {\n    //         // append the debug log to a #debug div\n    //         $(\"#debug\").append(str + \"\\n\");\n    //     };\n    //\n    // @example disable logging\n    //     client.debug = function(str) {};\n    //\n    // @note the default can generate lot of log on the console. Set it to empty function to disable\n    //\n    // @param message [String]\n    public debug = (...message) => {\n      console.log(...message);\n    };\n\n    // Base method to transmit any stomp frame\n    //\n    // @private\n    private _transmit(command, headers, body = ''): void {\n      let out = Frame.marshall(command, headers, body, this.escapeHeaderValues);\n      if (typeof this.debug === 'function') {\n        this.debug(`>>> ${out}`);\n      }\n      // if necessary, split the *STOMP* frame to send it on many smaller\n      // *WebSocket* frames\n      while (true) {\n        if (out.length > this.maxWebSocketFrameSize) {\n          this.ws.send(out.substring(0, this.maxWebSocketFrameSize));\n          out = out.substring(this.maxWebSocketFrameSize);\n          if (typeof this.debug === 'function') {\n            this.debug(`remaining = ${out.length}`);\n          }\n        } else {\n          this.ws.send(out);\n          return;\n        }\n      }\n    }\n\n    // Heart-beat negotiation\n    //\n    // @private\n    _setupHeartbeat(headers) {\n      let ttl;\n      if ((headers.version !== Stomp.VERSIONS.V1_1 && headers.version !== Stomp.VERSIONS.V1_2)) {\n        return;\n      }\n\n      // heart-beat header received from the server looks like:\n      //\n      //     heart-beat: sx, sy\n      const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(\",\").map((v) => parseInt(v));\n\n      if ((this.heartbeat.outgoing !== 0) && (serverIncoming !== 0)) {\n        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n        if (typeof this.debug === 'function') {\n          this.debug(`send PING every ${ttl}ms`);\n        }\n        // The `Stomp.setInterval` is a wrapper to handle regular callback\n        // that depends on the runtime environment (Web browser or node.js app)\n        this.pinger = Stomp.setInterval(ttl, () => {\n          this.ws.send(Byte.LF);\n          return (typeof this.debug === 'function' ? this.debug(\">>> PING\") : undefined);\n        });\n      }\n\n      if ((this.heartbeat.incoming !== 0) && (serverOutgoing !== 0)) {\n        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n        if (typeof this.debug === 'function') {\n          this.debug(`check PONG every ${ttl}ms`);\n        }\n        return this.ponger = Stomp.setInterval(ttl, () => {\n          const delta = Client.now() - this.serverActivity;\n          // We wait twice the TTL to be flexible on window's setInterval calls\n          if (delta > (ttl * 2)) {\n            if (typeof this.debug === 'function') {\n              this.debug(`did not receive server activity for the last ${delta}ms`);\n            }\n            return this.ws.close();\n          }\n        });\n      }\n    }\n\n    // parse the arguments number and type to find the headers, connectCallback and\n    // (eventually undefined) errorCallback\n    //\n    // @private\n    _parseConnect(...args) {\n      let closeEventCallback, connectCallback, errorCallback;\n      let headers = {};\n      if (args.length < 2) {\n        throw(\"Connect requires at least 2 arguments\");\n      }\n      if (typeof(args[1]) === 'function') {\n        [headers, connectCallback, errorCallback, closeEventCallback] = args;\n      } else {\n        switch (args.length) {\n          case 6:\n            [headers['login'], headers['passcode'], connectCallback, errorCallback, closeEventCallback, headers['host']] = args;\n            break;\n          default:\n            [headers['login'], headers['passcode'], connectCallback, errorCallback, closeEventCallback] = args;\n        }\n      }\n\n      return [headers, connectCallback, errorCallback, closeEventCallback];\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#CONNECT_or_STOMP_Frame CONNECT Frame\n    //\n    // The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n    // version with headers to pass your broker specific options.\n    //\n    // @overload connect(headers, connectCallback)\n    //\n    // @overload connect(headers, connectCallback, errorCallback)\n    //\n    // @overload connect(login, passcode, connectCallback)\n    //\n    // @overload connect(login, passcode, connectCallback, errorCallback)\n    //\n    // @overload connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n    //\n    // @overload connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n    //\n    // @param headers [Object]\n    // @option headers [String] login\n    // @option headers [String] passcode\n    // @option headers [String] host virtual host to connect to. STOMP 1.2 makes it mandatory, however the broker may not mandate it\n    // @param connectCallback [function(Frame)] Called upon a successful connect or reconnect\n    // @param errorCallback [function(any)] Optional, called upon an error. The passed paramer may be a {Frame} or a message\n    // @param closeEventCallback [function(CloseEvent)] Optional, called when the websocket is closed.\n    //\n    // @param login [String]\n    // @param passcode [String]\n    // @param host [String] Optional, virtual host to connect to. STOMP 1.2 makes it mandatory, however the broker may not mandate it\n    //\n    // @example\n    //        client.connect('guest, 'guest', function(frame) {\n    //          client.debug(\"connected to Stomp\");\n    //          client.subscribe(destination, function(message) {\n    //            $(\"#messages\").append(\"<p>\" + message.body + \"</p>\\n\");\n    //          });\n    //        });\n    //\n    // @note When auto reconnect is active, `connectCallback` and `errorCallback` will be called on each connect or error\n    connect(...args) {\n      this.escapeHeaderValues = false;\n      const out = this._parseConnect(...args);\n      [this.headers, this.connectCallback, this.errorCallback, this.closeEventCallback] = out;\n\n      // Indicate that this connection is active (it will keep trying to connect)\n      this._active = true;\n\n      return this._connect();\n    }\n\n    // Refactored to make it callable multiple times, useful for reconnecting\n    //\n    // @private\n    _connect() {\n      const {headers} = this;\n      const {errorCallback} = this;\n      const {closeEventCallback} = this;\n\n      this.debug(headers);\n\n      if (typeof this.debug === 'function') {\n        this.debug(\"Opening Web Socket...\");\n      }\n\n      // Get the actual Websocket (or a similar object)\n      this.ws = this.ws_fn();\n\n      this.ws.onmessage = evt => {\n        this.debug('Received data');\n        const data = (() => {\n          if ((typeof(ArrayBuffer) !== 'undefined') && evt.data instanceof ArrayBuffer) {\n            // the data is stored inside an ArrayBuffer, we decode it to get the\n            // data as a String\n            const arr = new Uint8Array(evt.data);\n            if (typeof this.debug === 'function') {\n              this.debug(`--- got data length: ${arr.length}`);\n            }\n            // Return a string formed by all the char codes stored in the Uint8array\n            let j, len1, results;\n            results = [];\n            for (j = 0, len1 = arr.length; j < len1; j++) {\n              const c = arr[j];\n              results.push(String.fromCharCode(c));\n            }\n\n            return results.join('');\n          } else {\n            // take the data directly from the WebSocket `data` field\n            return evt.data;\n          }\n        })();\n        this.debug(data);\n        this.serverActivity = Client.now();\n        if (data === Byte.LF) { // heartbeat\n          if (typeof this.debug === 'function') {\n            this.debug(\"<<< PONG\");\n          }\n          return;\n        }\n        if (typeof this.debug === 'function') {\n          this.debug(`<<< ${data}`);\n        }\n        // Handle STOMP frames received from the server\n        // The unmarshall function returns the frames parsed and any remaining\n        // data from partial frames.\n        const unmarshalledData = Frame.unmarshall(this.partialData + data, this.escapeHeaderValues);\n        this.partialData = unmarshalledData.partial;\n        for (let frame of unmarshalledData.frames) {\n          switch (frame.command) {\n            // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n            case \"CONNECTED\":\n              if (typeof this.debug === 'function') {\n                this.debug(`connected to server ${frame.headers.server}`);\n              }\n              this.connected = true;\n              this.version = frame.headers.version;\n              // STOMP version 1.2 needs header values to be escaped\n              if (this.version === Stomp.VERSIONS.V1_2) {\n                this.escapeHeaderValues = true;\n              }\n\n              // If a disconnect was requested while I was connecting, issue a disconnect\n              if (!this._active) {\n                // TODO: disconnect callback can no longer be part of disconnect call, it needs to be property of the\n                // client\n                this.disconnect(() => {});\n                return;\n              }\n\n              this._setupHeartbeat(frame.headers);\n              if (typeof this.connectCallback === 'function') {\n                this.connectCallback(frame);\n              }\n              break;\n            // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n            case \"MESSAGE\":\n              // the `onreceive` callback is registered when the client calls\n              // `subscribe()`.\n              // If there is registered subscription for the received message,\n              // we used the default `onreceive` method that the client can set.\n              // This is useful for subscriptions that are automatically created\n              // on the browser side (e.g. [RabbitMQ's temporary\n              // queues](http://www.rabbitmq.com/stomp.html)).\n              const {subscription} = frame.headers;\n              const onreceive = this.subscriptions[subscription] || this.onreceive;\n              if (onreceive) {\n                let messageID;\n                const client = this;\n                if (this.version === Stomp.VERSIONS.V1_2) {\n                  messageID = frame.headers[\"ack\"];\n                } else {\n                  messageID = frame.headers[\"message-id\"];\n                }\n                // add `ack()` and `nack()` methods directly to the returned frame\n                // so that a simple call to `message.ack()` can acknowledge the message.\n                frame.ack = headers => {\n                  if (headers == null) {\n                    headers = {};\n                  }\n                  return client.ack(messageID, subscription, headers);\n                };\n                frame.nack = headers => {\n                  if (headers == null) {\n                    headers = {};\n                  }\n                  return client.nack(messageID, subscription, headers);\n                };\n                onreceive(frame);\n              } else {\n                if (typeof this.debug === 'function') {\n                  this.debug(`Unhandled received MESSAGE: ${frame}`);\n                }\n              }\n              break;\n            // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n            //\n            // The client instance can set its `onreceipt` field to a function taking\n            // a frame argument that will be called when a receipt is received from\n            // the server:\n            //\n            //     client.onreceipt = function(frame) {\n            //       receiptID = frame.headers['receipt-id'];\n            //       ...\n            //     }\n            case \"RECEIPT\":\n              // if this is the receipt for a DISCONNECT, close the websocket\n              if (frame.headers[\"receipt-id\"] === this.closeReceipt) {\n                // Discard the onclose callback to avoid calling the errorCallback when\n                // the client is properly disconnected.\n                this.ws.onclose = null;\n                this.ws.close();\n                this._cleanUp();\n                if (typeof this._disconnectCallback === 'function') {\n                  this._disconnectCallback();\n                }\n              } else {\n                if (typeof this.onreceipt === 'function') {\n                  this.onreceipt(frame);\n                }\n              }\n              break;\n            // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n            case \"ERROR\":\n              if (typeof errorCallback === 'function') {\n                errorCallback(frame);\n              }\n              break;\n            default:\n              if (typeof this.debug === 'function') {\n                this.debug(`Unhandled frame: ${frame}`);\n              }\n          }\n        }\n      };\n      this.ws.onclose = closeEvent => {\n        const msg = `Whoops! Lost connection to ${this.ws.url}`;\n        if (typeof this.debug === 'function') {\n          this.debug(msg);\n        }\n        if (typeof closeEventCallback === 'function') {\n          closeEventCallback(closeEvent);\n        }\n        this._cleanUp();\n        if (typeof errorCallback === 'function') {\n          errorCallback(msg);\n        }\n        return this._schedule_reconnect();\n      };\n\n      return this.ws.onopen = () => {\n        if (typeof this.debug === 'function') {\n          this.debug('Web Socket Opened...');\n        }\n        headers[\"accept-version\"] = Stomp.VERSIONS.supportedVersions();\n        headers[\"heart-beat\"] = [this.heartbeat.outgoing, this.heartbeat.incoming].join(',');\n        this.debug(headers);\n        this._transmit(\"CONNECT\", headers);\n      };\n    }\n\n    //\n    // @private\n    _schedule_reconnect() {\n      if (this.reconnect_delay > 0) {\n        if (typeof this.debug === 'function') {\n          this.debug(`STOMP: scheduling reconnection in ${this.reconnect_delay}ms`);\n        }\n        // setTimeout is available in both Browser and Node.js environments\n        return this._reconnector = setTimeout(() => {\n            if (this.connected) {\n              return (typeof this.debug === 'function' ? this.debug('STOMP: already connected') : undefined);\n            } else {\n              if (typeof this.debug === 'function') {\n                this.debug('STOMP: attempting to reconnect');\n              }\n              return this._connect();\n            }\n          }\n          , this.reconnect_delay);\n      }\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#DISCONNECT DISCONNECT Frame\n    //\n    // Disconnect from the STOMP broker. To ensure graceful shutdown it sends a DISCONNECT Frame\n    // and wait till the broker acknowledges.\n    //\n    // disconnectCallback will be called only if the broker was actually connected.\n    //\n    // @param disconnectCallback [function()]\n    // @param headers [Object] optional\n    disconnect(disconnectCallback, headers = {}) {\n      this._disconnectCallback = disconnectCallback;\n\n      // indicate that auto reconnect loop should terminate\n      this._active = false;\n\n      if (this.connected) {\n        if (!headers['receipt']) {\n          headers['receipt'] = `close-${this.counter++}`;\n        }\n        this.closeReceipt = headers['receipt'];\n        try {\n          return this._transmit(\"DISCONNECT\", headers);\n        } catch (error) {\n          return (typeof this.debug === 'function' ? this.debug('Ignoring error during disconnect', error) : undefined);\n        }\n      }\n    }\n\n    // Clean up client resources when it is disconnected or the server did not\n    // send heart beats in a timely fashion\n    //\n    // @private\n    _cleanUp() {\n      // Clear if a reconnection was scheduled\n      if (this._reconnector) {\n        clearTimeout(this._reconnector);\n      }\n\n      this.connected = false;\n      this.subscriptions = {};\n      this.partial = '';\n      if (this.pinger) {\n        Stomp.clearInterval(this.pinger);\n      }\n      if (this.ponger) {\n        return Stomp.clearInterval(this.ponger);\n      }\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#SEND SEND Frame\n    //\n    // Send a message to a named destination. Refer to your STOMP broker documentation for types\n    // and naming of destinations. The headers will, typically, be available to the subscriber.\n    // However, there may be special purpose headers corresponding to your STOMP broker.\n    //\n    // @param destination [String] mandatory\n    // @param headers [Object] Optional\n    // @param body [String] Optional\n    //\n    // @example\n    //     client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n    //\n    // @example payload without headers\n    //     # If you want to send a message with a body, you must also pass the headers argument.\n    //     client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n    //\n    // @note Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n    send(destination, headers, body) {\n      if (headers == null) {\n        headers = {};\n      }\n      if (body == null) {\n        body = '';\n      }\n      headers.destination = destination;\n      return this._transmit(\"SEND\", headers, body);\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#SUBSCRIBE SUBSCRIBE Frame\n    //\n    // Subscribe to a STOMP Broker location. The return value is an Object with unsubscribe method.\n    //\n    // @example\n    //    callback = function(message) {\n    //      // called when the client receives a STOMP message from the server\n    //      if (message.body) {\n    //        alert(\"got message with body \" + message.body)\n    //      } else\n    //      {\n    //        alert(\"got empty message\");\n    //      }\n    //    });\n    //\n    //  var subscription = client.subscribe(\"/queue/test\", callback);\n    //\n    // @example Explicit subscription id\n    //      var mysubid = 'my-subscription-id-001';\n    //      var subscription = client.subscribe(destination, callback, { id: mysubid });\n    //\n    // @param destination [String]\n    // @param callback [function(message)]\n    // @param headers [Object] optional\n    // @return [Object] this object has a method to `unsubscribe`\n    //\n    // @note The library will generate an unique ID if there is none provided in the headers. To use your own ID, pass it using the headers argument\n    subscribe(destination, callback, headers) {\n      // for convenience if the `id` header is not set, we create a new one for this client\n      // that will be returned to be able to unsubscribe this subscription\n      if (headers == null) {\n        headers = {};\n      }\n      if (!headers.id) {\n        headers.id = `sub-${this.counter++}`;\n      }\n      headers.destination = destination;\n      this.subscriptions[headers.id] = callback;\n      this._transmit(\"SUBSCRIBE\", headers);\n      const client = this;\n      return {\n        id: headers.id,\n\n        unsubscribe(hdrs) {\n          return client.unsubscribe(headers.id, hdrs);\n        }\n      };\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n    //\n    // It is preferable to unsubscribe from a subscription by calling\n    // `unsubscribe()` directly on the object returned by `client.subscribe()`:\n    //\n    // @example\n    //     var subscription = client.subscribe(destination, onmessage);\n    //     ...\n    //     subscription.unsubscribe();\n    //\n    // @param id [String]\n    // @param headers [Object] optional\n    unsubscribe(id, headers) {\n      if (headers == null) {\n        headers = {};\n      }\n      delete this.subscriptions[id];\n      headers.id = id;\n      return this._transmit(\"UNSUBSCRIBE\", headers);\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#BEGIN BEGIN Frame\n    //\n    // Start a transaction, the returned Object has methods - `commit` and `abort`\n    //\n    // @param transaction_id [String] optional\n    // @return [Object] member, `id` - transaction id, methods `commit` and `abort`\n    //\n    // @note If no transaction ID is passed, one will be created automatically\n    begin(transaction_id) {\n      const txid = transaction_id || (`tx-${this.counter++}`);\n      this._transmit(\"BEGIN\", {\n        transaction: txid\n      });\n      const client = this;\n      return {\n        id: txid,\n        commit() {\n          return client.commit(txid);\n        },\n        abort() {\n          return client.abort(txid);\n        }\n      };\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#COMMIT COMMIT Frame\n    //\n    // Commit a transaction.\n    // It is preferable to commit a transaction by calling `commit()` directly on\n    // the object returned by `client.begin()`:\n    //\n    // @param transaction_id [String]\n    //\n    // @example\n    //     var tx = client.begin(txid);\n    //     ...\n    //     tx.commit();\n    commit(transaction_id) {\n      return this._transmit(\"COMMIT\", {\n        transaction: transaction_id\n      });\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#ABORT ABORT Frame\n    //\n    // Abort a transaction.\n    // It is preferable to abort a transaction by calling `abort()` directly on\n    // the object returned by `client.begin()`:\n    //\n    // @param transaction_id [String]\n    //\n    // @example\n    //     var tx = client.begin(txid);\n    //     ...\n    //     tx.abort();\n    abort(transaction_id) {\n      return this._transmit(\"ABORT\", {\n        transaction: transaction_id\n      });\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#ACK ACK Frame\n    //\n    // ACK a message. It is preferable to acknowledge a message by calling `ack()` directly\n    // on the message handled by a subscription callback:\n    //\n    // @example\n    //     client.subscribe(destination,\n    //       function(message) {\n    //         // process the message\n    //         // acknowledge it\n    //         message.ack();\n    //       },\n    //       {'ack': 'client'}\n    //     );\n    //\n    // @param messageID [String]\n    // @param subscription [String]\n    // @param headers [Object] optional\n    ack(messageID, subscription, headers) {\n      if (headers == null) {\n        headers = {};\n      }\n      if (this.version === Stomp.VERSIONS.V1_2) {\n        headers[\"id\"] = messageID;\n      } else {\n        headers[\"message-id\"] = messageID;\n      }\n      headers.subscription = subscription;\n      return this._transmit(\"ACK\", headers);\n    }\n\n    // @see http://stomp.github.com/stomp-specification-1.2.html#NACK NACK Frame\n    //\n    // NACK a message. It is preferable to nack a message by calling `nack()` directly on the\n    // message handled by a subscription callback:\n    //\n    // @example\n    //     client.subscribe(destination,\n    //       function(message) {\n    //         // process the message\n    //         // an error occurs, nack it\n    //         message.nack();\n    //       },\n    //       {'ack': 'client'}\n    //     );\n    //\n    // @param messageID [String]\n    // @param subscription [String]\n    // @param headers [Object] optional\n    nack(messageID, subscription, headers) {\n      if (headers == null) {\n        headers = {};\n      }\n      if (this.version === Stomp.VERSIONS.V1_2) {\n        headers[\"id\"] = messageID;\n      } else {\n        headers[\"message-id\"] = messageID;\n      }\n      headers.subscription = subscription;\n      return this._transmit(\"NACK\", headers);\n    }\n  }","import {Stomp} from \"./stomp\";\n\nexport * from './headers';\nexport * from './client';\nexport * from './frame';\nexport * from './stomp';\n"],"sourceRoot":""}